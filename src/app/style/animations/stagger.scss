@use "sass:map";

$maxChildren: 6;

// Defaults
// #children: Children to be staggered of the element which is applied the mixin
// initialDelay: the delay in seconds before the stagger should starts
// #animationDuration: the duration in seconds of the animation applied to each element
// #staggerFactor: how much delay in seconds, relative to animation duration, between staggers.
// values <= 0 are forbidden
// Examples:
// value of 1 will trigger the animation of the next element after the current element animation finishes
// value of .5 will trigger the animation of the next element when the current element animation is halfway through
// value of 2 will trigger the animation of the next element after the 2x the animation time
// #inverse: stagger the delay starting from the last child
$defaults: (
        "children": $maxChildren,
        "initialDelay": 0,
        "animationDuration": .4,
        "staggerFactor": .4,
        "inverse": false
);

// Calculates the animation delay based on the child index
@function getAnimationDelay($childIndex: 1,
  $initialDelay: map.get($defaults, "initialDelay"),
  $animationDuration: map.get($defaults, "animationDuration"),
  $staggerFactor: map.get($defaults, "staggerFactor")) {
  @return '(#{(($animationDuration * $childIndex) * $staggerFactor)} + #{$initialDelay}) * 1s'
}

/**
 * The main mixin of the module, ideally the only one to be used.
 * It enables the consumer to control the stagger effect by specifying the number of children for the element it is applied to.
 *
 * The mixin supports recursive usage, which means that when applied to a staggered element,
 * the stagger effect will trigger once the parent element finishes its animation and becomes visible.
 *
 * The consumer has the flexibility to specify any combination of props in any order.
 * Example of usage:
 * stagger($children: 5) will stagger 5 elements
 * stagger($initialDelay: 20) will stagger the default number of elements after 20 seconds
 * stagger($initialDelay: 20, children: 5) will stagger the first 5 elements after 20 seconds
 *
 * @param {number} $children - The number of children to be staggered of the element to which the mixin is applied.
 * @param {number} $initialDelay - The delay in seconds before the stagger starts.
 * @param {number} $animationDuration - The duration in seconds of the animation applied to each element.
 * @param {number} $staggerFactor - How much delay in seconds, relative to animation duration, between staggers.
 * @param {boolean} $inverse - Whether to stagger the delay starting from the last child.
 * @return {void}
 * Note: $children is deprecated and will be removed in future versions.
 */
@mixin stagger(
  $children: map.get($defaults, "children"),
  $initialDelay: map.get($defaults, "initialDelay"),
  $animationDuration: map.get($defaults, "animationDuration"),
  $staggerFactor: map.get($defaults, "staggerFactor"),
  $inverse:  map.get($defaults, "inverse")
) {

  @if $children != null {
    @warn "The use of $children is deprecated and will be removed in future versions.";
  }
  @if ($children == null) {
    $children: $maxChildren;
  }

  @if($children > $maxChildren) {
    $children: $maxChildren;
  }

  * {
    $animationDelay: 0;
    @if($inverse == true) {
      $animationDelay: getAnimationDelay($children, $initialDelay, $animationDuration, $staggerFactor);
    }
    @if($inverse == false) {
      $animationDelay: getAnimationDelay($children, $initialDelay, $animationDuration, $staggerFactor);
    }
    --delay: #{$animationDelay};

    animation-duration: calc(#{ $animationDuration } * 1s);
    animation-delay: var(--delay);
  }

  @for $i from 1 through $children + 1 {
    > *:nth-child(#{$i}),> *:nth-child(#{$i}):before, > *:nth-child(#{$i}):after {
      $animationDelay: 0;
      @if($inverse == true) {
        $animationDelay: getAnimationDelay($children - $i, $initialDelay, $animationDuration, $staggerFactor);
      }
      @if($inverse == false) {
        $animationDelay: getAnimationDelay($i - 1, $initialDelay, $animationDuration, $staggerFactor);
      }
      --delay: calc(#{$animationDelay} + var(--parent-delay, 0s));

      > * {
        --parent-delay: #{$animationDelay};
      }

      animation-duration: calc(#{ $animationDuration } * 1s);
      animation-delay: var(--delay);
    }
  }
}
